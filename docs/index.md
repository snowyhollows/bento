# Bento - a Quick Start

## The basic workflow

Bento is an object which stores both the configuration data (strings, floats, enum values etc.) and all the objects of which an application consists. Bento is the glue that connects all the components of the application, delivering the configuration and services to the objects that need them.

Bento can be used to purge the application of singletons, statics and global variables.

Each Bento instance can be thought of as a single "context" or "scope" - containing a map from:

 - string keys to values of any types
 - factory instances to objects created by those factories.

Bento is a light-weight object, but it makes sense to create only one application-wide Bento, preferably at startup. Then a child Bento can be created each time we need to override parts of the configuration. Child bentos are created by calling `createChild` method on the parent Bento. They allow access to all the values defined on their parents, but also allow registering their own values, which will shade anything defined on the parent.

Child Bentos are also light-weight (around the size of a `HashMap`), so they can be created and thrown away without much performance penalty.

### Configuring and creating Bento

After configuring a `Bento`, values can be assigned to its keys with the `register` method.

```java

/** 
 * The main class of the application. 
 */
class BootStrap {

    public static void main(String[] args) {
        // create the first, parentless bento
        Bento bento = Bento.createRoot();

        // configure the bento
        bento.register("width", 800);
        bento.register("height", 600);

        // create the main object
        
        // TODO
        
        // run the main object
        
        // TODO
    }
}
```

Any value registered in a Bento can be retrieved by one of Bento's typed `getXXX` methods, which attempt to perform conversion on the stored value. For example `bento.getInt("width")` will return an int of 800, but `bento.getFloat("width")` returns a float.

One of the possible conversions is creating enum instances. Assuming we have an enum with the names of colors, we can register a color as a string and retrieve it as the enum instance:

```jshelllanguage
enum Color {
    RED, GREEN, BLUE
}

Bento bento = Bento.createRoot();
bento.register("color", "RED");
Color color = bento.getEnum(Color.class, "color");
```

## Creating objects

The various getXXX methods are not meant to be used directly. Instead, when creating classes that depend on configuration values, we assume that the values will be passed directly into their constructor. By annotating a single constructor of such class with the `@WithFactory` annotation, we instruct Bento's annotation processor to create a static factory for it.

```java

/** Type safe wrapper for the screen size configuration. */
public class ScreenSizeConfig {
    public  final float width;
    public final float height;
    
    @WithFactory
    public ScreenSizeConfig(float width, float height) {
        this.width = width;
        this.height = height;
    }
    
}
```
Factories generated by Bento are devoid of magic. They only serve as a bridge between dynamically typed world of runtime configuration - and the static world of dependencies. In this case Bento will generate a factory with the following contents:

```java
public enum ScreenSizeConfigFactory implements BentiFactory<ScreenSizeConfig>{
    IT;
    
    public ScreenSizeConfig createInContext(Bento bento) {
        return new ScreenSizeConfig(bento.getFloat(width), bento.getFloat(height));
    }
}

```

Factories generated by Bento are always stateless and always depend only on a single Bento as an argument. We can imagine those factories as pure functions from "certain configuration context" to "an instance of certain class".

The factory could be used directly, but - again - it is not meant for direct use. Instead, we create code that looks as if we tried to get the object from the Bento with the factory as the key:

```jshelllanguage
Bento bento = Bento.createRoot();
bento.register("width", 800);
bento.register("height", 600);

var config = bento.get(ScreenSizeConfigFactory.IT); // returns new ScreenSizeConfig(800, 600)
var same = bento.get(ScreenSizeConfigFactory.IT); // returns the same object
```

If the key was not registered, Bento will use the factory to create an instance, register the instance and return it. If the key is already associated with a value - the value will be returned.
Since the factories are singletons, each call will return the same `ScreenSize` instance. This way - a Bento acts as a lazy factory.

## Resolving dependencies

It's possible to `get` multiple objects from Bento, but it's not the intended usage.

The actual way to get the `ScreenSizeConfig` instance is to declare it as an argument to a constructor of another class:

```java

class SpriteInCenterDisplayer {
    private final MySpriteHandler handler;
    private final ScreenSizeConfig screenSize;

    @WithFactory
    public SpriteDisplayer(MySpriteHandler handler, ScreenSizeConfig screenSize) {
        this.handler = handler;
        this.screenSize = screenSize;
    }

    public void displayInTheMiddle(Sprite sprite) {
        handler.display(sprite, screenSize.width / 2, screenSize.height / 2);
    }
}

```

For the above class, Bento will create the following factory:

```java
public enum SpriteDisplayerFactory implements BentoFactory<SpriteDisplayer>{
    IT;
    
    public SpriteDisplayer createInContext(Bento bento) {
        return new SpriteDisplayer(
                bento.get(MySpriteHandlerFactory.IT),
                bento.get(ScreenSizeConfigFactory.IT));
    }
}
```

> Note that for dependencies on object other than a primitive (int, short, float, Enum, String, boolean, double, long) - Bento assumes existence of the auto-generated factory.

## Turtles all the way down

In realistic applications - Bento factories are deeply nested. A factory for each object triggers creation of its dependencies, those dependencies - in turn - create their dependencies, and so on. The process ends with primitive dependencies like strings and numbers.

With a single call constructing a top level application object - the whole graph of dependencies is created, depth-first. The lazy nature of Bento ensures that only one instance of each type is created, and that the objects are created only when they are needed.

This also means that there should be only one direct call necessary to Bento's `get` method. The call should return a fully configured application, ready to run.

## Multiple instances

In some cases, we may want to create multiple instances of the same class, each with a slightly different configuration. This is the point of child Bentos, which represent "scope".

The scopes can be larger, like an entire application, but can be as small as a single object in a game.

Let's imagine an class representing a sprite in a game:

```java

public class Sprite {
    private final float x;
    private final float y;
    private final Texture texture;
    
    @WithFactory
    public Sprite(float x, float y, String textureName, TextureService textureService) {
        this.x = x;
        this.y = y;
        this texture = textureService.getTexture(textureName);
    }
    
    // TODO
}

```

For a moment, let's not think if passing the `TextureService` to the constructor is a good idea. Let's just assume it was, at the moment, the fastest way for the programmer to move forward.

We could imagine a service that spawns sprites at random locations:

```java

public class SpriteSpawner {
    private final Bento bento;
    private final World world;
    private final ScreenSizeConfig screenSize;
    
    @WithFactory
    public SpriteSpawner(Bento bento, World world, ScreenSizeConfig screenSize) {
        this.bento = bento;
        this.world = world;
        this.screenSize = screenSize;
    }
    
    public void step() {
        if (Math.random() < 0.1) {
            float x = Math.random() * screenSize.width;
            float y = Math.random() * screenSize.height;
            
            var childBento = bento.createChild();
            childBento.register("x", x);
            childBento.register("y", y);
            Sprite sprite = childBento.get(SpriteFactory.IT);;
            world.add(sprite);
        }
    }
}
```

> Note how the service can simply declare that it needs to know the screen size - and how it doesn't care about the texture name. We can assume that the default texture name is configured in the root Bento. Also, note how sprites need a `TextureService`, but `SpriteSpawner` doesn't care about it. Dependencies of a `Sprite` can change, but this will never affect the code of the service spawning sprites, making refactorings easier and preventing the ripple effect.

However, Bento can do better.

The need of creating an object with a slightly different configuration is a common one, so there is one more generator provided - the bento wrapper.

With bento wrapper, we can wrap the functionality of:
- creating a child bento
- registering some named values on it
- getting an object from it

It's enough to declare an interface and annotate it with `@BentoWrapper`:

```java

@BentoWrapper
public interface SpriteFactory {
    Sprite create(float x, float y);
}
```

Bento will take care of both generating the very simple implementation, and the factory for it, allowing the implementation to be injected. The generated code will be simple, human-readable and easy to understand, similar to this:

```java

public enum SpriteFactoryFactory implements BentoFactory<SpriteFactory>{
    IT;
    
    public SpriteFactory createInContext(Bento bento) {
        return new SpriteFactory() {
            public Sprite create(float x, float y) {
                var childBento = bento.createChild();
                childBento.register("x", x);
                childBento.register("y", y);
                return childBento.get(SpriteFactory.IT);
            }
        };
    }
}
```

In result, we can simplify the `SpriteSpawner` code:

```java

public class SpriteSpawner {
    private final SpriteFactory spriteFactory;
    private final World world;
    private final ScreenSizeConfig screenSize;
    
    @WithFactory
    public SpriteSpawner(SpriteFactory spriteFactory, World world, ScreenSizeConfig screenSize) {
        this.spriteFactory = spriteFactory;
        this.world = world;
        this.screenSize = screenSize;
    }
    
    public void step (float x, float y) {
        if (Math.random() < 0.1) {
            float x = Math.random() * screenSize.width;
            float y = Math.random() * screenSize.height;
            Sprite sprite = spriteFactory.create(x, y);
            world.add(sprite);
        }
    }
}
```
